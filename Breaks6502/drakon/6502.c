/* Autogenerated with DRAKON Editor 1.15 */
#include "6502.h"

#include "PLA.h"

#include <stdio.h>

#define PHI1    (cpu->PHI1)
#define PHI2    (cpu->PHI2)

// Basic logic
#define BIT(n)     ( (n) & 1 )
int NOT(int a) { return (~a & 1); }
int NAND(int a, int b) { return ~((a & 1) & (b & 1)) & 1; }
int NOR(int a, int b) { return ~((a & 1) | (b & 1)) & 1; }

// Top part context
// =============================================================

int nNMI, nIRQ, RES;
static char BRK5Latch, BRKDelayLatch, BRKDONELatch;
int BRKDELAY, BRKDONE;
int RDY, PREVRDY;
static char PREVRDY_Latch[2];
int nRDY;
int SO;
static unsigned char T, IR, PD;
char PLA[129];   // 129 active lines.
int iANDS, iEORS, iORS, iSRS;
static char ANDS_SR[2], SUMS_SR[2];
int TWOCYCLE, IMPLIED;
static char WRLatch;

// Bottom-part controls
int CTRL_ADH_ABH, CTRL_ADL_ABL, CTRL_Y_SB, CTRL_X_SB, CTRL_ZERO_ADL0, CTRL_ZERO_ADL1, CTRL_ZERO_ADL2,
    CTRL_SB_Y, CTRL_SB_X, CTRL_S_SB, CTRL_S_ADL, CTRL_SB_S, CTRL_S_S, CTRL_nDB_ADD, CTRL_DB_ADD,
    CTRL_ZERO_ADD, CTRL_SB_ADD, CTRL_ADL_ADD, CTRL_ANDS, CTRL_EORS, CTRL_ORS, CTRL_I_ADDC, CTRL_SRS, CTRL_SUMS, CTRL_DAA,
    CTRL_ADD_SB7, CTRL_ADD_SB06, CTRL_ADD_ADL, CTRL_DSA, CTRL_AVR, CTRL_ACR, CTRL_ZERO_ADH0, CTRL_SB_DB, CTRL_SB_AC,
    CTRL_SB_ADH, CTRL_ZERO_ADH17, CTRL_AC_SB, CTRL_AC_DB, CTRL_ADH_PCH, CTRL_PCH_PCH, CTRL_PCH_DB, CTRL_PCL_DB,
    CTRL_PCH_ADH, CTRL_PCL_PCL, CTRL_PCL_ADL, CTRL_ADL_PCL, CTRL_IPC, CTRL_DL_ADL, CTRL_DL_ADH, CTRL_DL_DB;

// Bottom part context
// =============================================================

static unsigned char X, Y, S, AI, BI, ADD, AC, PCL, PCLS, PCH, PCHS, DOR, DL, ABH, ABL;
unsigned char SB, DB, ADH, ADL;
static int OverflowLatch, BinaryCarry, DecimalCarry;
static int LatchDAAL, LatchDSAL, LatchDAAH, LatchDSAH;


// =============================================================




static void ACR_AVR(
    Context6502 * cpu
);

static void ACR_LATCH(
    Context6502 * cpu
);

static void AC_SB(
    Context6502 * cpu
);

static void ADDRESS_BUS(
    Context6502 * cpu
);

static void ADD_SB7(
    Context6502 * cpu
);

static void ADH_ABH(
    Context6502 * cpu
);

static void ADL_ABL(
    Context6502 * cpu
);

static void ALU(
    Context6502 * cpu
);

static void ALU_SETUP(
    Context6502 * cpu
);

static void ANDS(
    Context6502 * cpu
);

static void BOTTOM_PART(
    Context6502 *cpu
);

static void BRANCH_BACK(
    Context6502 * cpu
);

static void BRANCH_LOGIC(
    Context6502 * cpu
);

static void B_FLAG(
    Context6502 * cpu,
    int out
);

static void CLOCK(
    Context6502 *cpu
);

static void C_FLAG(
    Context6502 * cpu,
    int out
);

static void DAA_DSA(
    Context6502 * cpu
);

static void DECODER(
    Context6502 * cpu
);

static void DL_ADH(
    Context6502 * cpu
);

static void DL_ADL(
    Context6502 * cpu
);

static void DL_DB(
    Context6502 * cpu
);

static void D_FLAG(
    Context6502 * cpu,
    int out
);

static void ENDS(
    Context6502 * cpu
);

static void ENDX(
    Context6502 * cpu
);

static void EXEC_CTRL(
    Context6502 * cpu,
    int out
);

static void FETCH(
    Context6502 * cpu
);

static void FLAG_CTRL(
    Context6502 * cpu
);

static void FLAG_IO(
    Context6502 * cpu
);

static void IND(
    Context6502 * cpu
);

static void INSTR_REG(
    Context6502 * cpu
);

static void INT_ADDR(
    Context6502 * cpu
);

static void INT_END(
    Context6502 * cpu
);

static void IPC(
    Context6502 * cpu
);

static void IRQ_PAD(
    Context6502 * cpu
);

static void I_FLAG(
    Context6502 * cpu,
    int out
);

static void MEMOP(
    Context6502 * cpu
);

static void NMI_DETECT(
    Context6502 * cpu
);

static void NMI_PAD(
    Context6502 * cpu
);

static void NOADL(
    Context6502 * cpu
);

static void N_FLAG(
    Context6502 * cpu,
    int out
);

static void PC_SETUP(
    Context6502 * cpu
);

static void PREDECODE(
    Context6502 * cpu
);

static void PROGRAM_COUNTER(
    Context6502 * cpu
);

static void RDY_PAD(
    Context6502 * cpu
);

static void READY_CTRL(
    Context6502 * cpu,
    int out
);

static void REGS(
    Context6502 * cpu
);

static void RES_DETECT(
    Context6502 * cpu,
    int out
);

static void RES_PAD(
    Context6502 * cpu
);

static void RW_PAD(
    Context6502 * cpu
);

static void RW_SELECT(
    Context6502 * cpu
);

static void SB_AC(
    Context6502 * cpu
);

static void SB_ADH(
    Context6502 * cpu
);

static void SB_DB(
    Context6502 * cpu
);

static void SB_XY(
    Context6502 * cpu
);

static void SO_PAD(
    Context6502 * cpu
);

static void SREG_CTRL(
    Context6502 * cpu
);

static void SRS(
    Context6502 * cpu
);

static void STOR(
    Context6502 * cpu
);

static void SUMS(
    Context6502 * cpu
);

static void T0_T1(
    Context6502 * cpu
);

static void T2_T5(
    Context6502 * cpu
);

static void T5_T6(
    Context6502 * cpu
);

static void TOP_PART(
    Context6502 *cpu
);

static void T_CTRL(
    Context6502 * cpu,
    int out
);

static void V_FLAG(
    Context6502 * cpu,
    int out
);

static void WR_DL(
    Context6502 * cpu
);

static void XY_SB(
    Context6502 * cpu
);

static void ZERO_ADH0(
    Context6502 * cpu
);

static void ZERO_ADH17(
    Context6502 * cpu
);

static void Z_FLAG(
    Context6502 * cpu,
    int out
);

static void ACR_AVR(
    Context6502 * cpu
) {
}

static void ACR_LATCH(
    Context6502 * cpu
) {
}

static void AC_SB(
    Context6502 * cpu
) {
}

static void ADDRESS_BUS(
    Context6502 * cpu
) {
    // item 172
    if (PHI1) {
        /* item 175 */
        ADL &= ~ ((CTRL_ZERO_ADL2 << 2) | (CTRL_ZERO_ADL1 << 1) | (CTRL_ZERO_ADL0 << 0));
        if (CTRL_ZERO_ADH0) ADH &= ~0x01;
        if (CTRL_ZERO_ADH17) ADH &= ~0xFE;
        if (CTRL_ADH_ABH) ABH = ADH;
        if (CTRL_ADL_ABL) ABL = ADL;
        return;
    } else {
        return;
    }
    
}

static void ADD_SB7(
    Context6502 * cpu
) {
}

static void ADH_ABH(
    Context6502 * cpu
) {
}

static void ADL_ABL(
    Context6502 * cpu
) {
}

static void ALU(
    Context6502 * cpu
) {
}

static void ALU_SETUP(
    Context6502 * cpu
) {
}

static void ANDS(
    Context6502 * cpu
) {
    // item 694
    iANDS = PLA[69] | PLA[70];
    
    // item 695
    if (PHI2) {
        /* item 698 */
        ANDS_SR[0] = iANDS;
    } else {
    }
    
    // item 699
    if (PHI1) {
        /* item 702 */
        ANDS_SR[1] = NOT(ANDS_SR[0]);
    } else {
    }
    
    // item 703
    CTRL_ANDS = NOT(ANDS_SR[1]);
    return;
    
}

static void BOTTOM_PART(
    Context6502 *cpu
) {
    // item 311
    if (PHI2) {
        /* item 314 */
        // precharge internal buses
        SB = DB = ADH = ADL = 0xff;
        return;
    } else {
        return;
    }
    
}

static void BRANCH_BACK(
    Context6502 * cpu
) {
}

static void BRANCH_LOGIC(
    Context6502 * cpu
) {
}

static void B_FLAG(
    Context6502 * cpu,
    int out
) {
}

static void CLOCK(
    Context6502 *cpu
) {
    // item 104
    cpu->PHI0 = BIT (cpu->PHI0);
    PHI1 = NOT(cpu->PHI0);
    PHI2 = cpu->PHI0;
    return;
    
}

static void C_FLAG(
    Context6502 * cpu,
    int out
) {
}

static void DAA_DSA(
    Context6502 * cpu
) {
}

static void DECODER(
    Context6502 * cpu
) {
}

static void DL_ADH(
    Context6502 * cpu
) {
}

static void DL_ADL(
    Context6502 * cpu
) {
}

static void DL_DB(
    Context6502 * cpu
) {
}

static void D_FLAG(
    Context6502 * cpu,
    int out
) {
}

static void ENDS(
    Context6502 * cpu
) {
}

static void ENDX(
    Context6502 * cpu
) {
}

static void EXEC_CTRL(
    Context6502 * cpu,
    int out
) {
}

static void FETCH(
    Context6502 * cpu
) {
}

static void FLAG_CTRL(
    Context6502 * cpu
) {
}

static void FLAG_IO(
    Context6502 * cpu
) {
}

static void IND(
    Context6502 * cpu
) {
}

static void INSTR_REG(
    Context6502 * cpu
) {
}

static void INT_ADDR(
    Context6502 * cpu
) {
}

static void INT_END(
    Context6502 * cpu
) {
    // item 944
    int BRK5 = NOR ( nRDY, NOT(PLA[22]) );
    /* item 943 */
    if (PHI2) BRK5Latch = BRK5;
    if (PHI1) {
        if (nRDY) BRKDelayLatch = NOR ( NOT(BRKDelayLatch), BRK5Latch );
        else BRKDelayLatch = NOT(BRK5Latch);
    }
    BRKDELAY = NOR ( NOT(BRKDelayLatch), BRK5 );
    if (PHI2) BRKDONELatch = NOT(BRKDelayLatch);
    BRKDONE = NOR ( nRDY, NOT(BRKDONELatch) );
    /* item 945 */
    //printf ( "PHI:%i BRKDONE=%i BRKDELAY=%i, BRK5=%i\n", cpu->PHI0, BRKDONE, BRKDELAY, BRK5);
    return;
    
}

static void IPC(
    Context6502 * cpu
) {
}

static void IRQ_PAD(
    Context6502 * cpu
) {
    // item 542
    nIRQ = 1;
    return;
    
}

static void I_FLAG(
    Context6502 * cpu,
    int out
) {
}

static void MEMOP(
    Context6502 * cpu
) {
}

static void NMI_DETECT(
    Context6502 * cpu
) {
}

static void NMI_PAD(
    Context6502 * cpu
) {
    // item 541
    nNMI = 1;
    return;
    
}

static void NOADL(
    Context6502 * cpu
) {
}

static void N_FLAG(
    Context6502 * cpu,
    int out
) {
}

static void PC_SETUP(
    Context6502 * cpu
) {
}

static void PREDECODE(
    Context6502 * cpu
) {
    // item 309
    int p[4];
    
    #define PD(n)   ((PD >> n) & 1)
    #define nPD(n)  (NOT((PD >> n) & 1))
    
    // item 305
    if (PHI2) {
        /* item 308 */
        PD = cpu->DATA;
    } else {
    }
    
    // item 310
    // Determine whenever instruction takes 2 cycle / implied.
    p[0] = NOT ( PD(2) | nPD(3) | PD(4) | nPD(0) );     // XXX010X1
    p[1] = NOT ( PD(2) | nPD(3) | PD(0) );      // XXXX10X0
    p[2] = NOT ( PD(4) | PD(7) | PD(1) );       // 0XX0XX0X
    p[3] = NOT ( PD(2) | PD(3) | PD(4) | nPD(7) | PD(0) );  // 1XX000X0
    TWOCYCLE = p[0] | p[3] | (NOT(p[2]) & p[1]);
    IMPLIED = p[1];
    return;
    
}

static void PROGRAM_COUNTER(
    Context6502 * cpu
) {
}

static void RDY_PAD(
    Context6502 * cpu
) {
    // item 544
    RDY = cpu->RDY;
    
    // item 545
    if (PHI2) {
        /* item 548 */
        PREVRDY_Latch[0] = NOT(cpu->RDY);
    } else {
    }
    
    // item 549
    if (PHI1) {
        /* item 552 */
        PREVRDY_Latch[1] = NOT(PREVRDY_Latch[0]);
    } else {
    }
    
    // item 553
    PREVRDY = NOT (PREVRDY_Latch[1]);
    return;
    
}

static void READY_CTRL(
    Context6502 * cpu,
    int out
) {
}

static void REGS(
    Context6502 * cpu
) {
    // item 160
    if (PHI1) {
        /* item 163 */
        if (CTRL_X_SB) SB = X;
        else if (CTRL_SB_X) X = SB;
        if (CTRL_Y_SB) SB = Y;
        else if (CTRL_SB_Y) Y = SB;
        if (CTRL_SB_S) S = SB;
        else if (CTRL_S_SB) SB = S;
        if (CTRL_S_ADL) ADL = S;
        return;
    } else {
        return;
    }
    
}

static void RES_DETECT(
    Context6502 * cpu,
    int out
) {
}

static void RES_PAD(
    Context6502 * cpu
) {
    // item 543
    RES = 1;
    return;
    
}

static void RW_PAD(
    Context6502 * cpu
) {
    // item 725
    cpu->RW = NOT (WRLatch);
    return;
    
}

static void RW_SELECT(
    Context6502 * cpu
) {
}

static void SB_AC(
    Context6502 * cpu
) {
}

static void SB_ADH(
    Context6502 * cpu
) {
}

static void SB_DB(
    Context6502 * cpu
) {
}

static void SB_XY(
    Context6502 * cpu
) {
}

static void SO_PAD(
    Context6502 * cpu
) {
    // item 554
    SO = 0;
    return;
    
}

static void SREG_CTRL(
    Context6502 * cpu
) {
}

static void SRS(
    Context6502 * cpu
) {
}

static void STOR(
    Context6502 * cpu
) {
}

static void SUMS(
    Context6502 * cpu
) {
    // item 742
    int iSUMS = NOT ( iANDS | iEORS | iORS | iSRS );
    
    // item 743
    if (PHI2) {
        /* item 746 */
        SUMS_SR[0] = iSUMS;
    } else {
    }
    
    // item 747
    if (PHI1) {
        /* item 750 */
        SUMS_SR[1] = NOT(SUMS_SR[0]);
    } else {
    }
    
    // item 751
    CTRL_SUMS = NOT(SUMS_SR[1]);
    return;
    
}

static void T0_T1(
    Context6502 * cpu
) {
}

static void T2_T5(
    Context6502 * cpu
) {
}

static void T5_T6(
    Context6502 * cpu
) {
}

static void TOP_PART(
    Context6502 *cpu
) {
    // item 197
    CLOCK (cpu);
    /* item 198 */
    NMI_PAD (cpu);
    /* item 199 */
    IRQ_PAD (cpu);
    /* item 200 */
    RES_PAD (cpu);
    /* item 540 */
    SO_PAD (cpu);
    /* item 555 */
    RDY_PAD (cpu);
    /* item 835 */
    READY_CTRL (cpu,1);
    /* item 787 */
    ACR_AVR (cpu);
    /* item 608 */
    ACR_LATCH (cpu);
    /* item 581 */
    NMI_DETECT (cpu);
    /* item 951 */
    RES_DETECT (cpu,1);
    /* item 825 */
    I_FLAG (cpu,1);
    /* item 826 */
    C_FLAG (cpu,1);
    /* item 827 */
    D_FLAG (cpu,1);
    /* item 828 */
    V_FLAG (cpu,1);
    /* item 829 */
    N_FLAG (cpu,1);
    /* item 830 */
    B_FLAG (cpu,1);
    /* item 836 */
    T_CTRL (cpu,1);
    /* item 805 */
    T0_T1 (cpu);
    /* item 806 */
    T2_T5 (cpu);
    /* item 837 */
    EXEC_CTRL (cpu,1);
    /* item 812 */
    FETCH (cpu);
    /* item 816 */
    PREDECODE (cpu);
    /* item 818 */
    INSTR_REG (cpu);
    /* item 559 */
    DECODER (cpu);
    /* item 952 */
    RES_DETECT (cpu,0);
    /* item 796 */
    INT_END (cpu);
    /* item 582 */
    INT_ADDR (cpu);
    /* item 576 */
    BRANCH_BACK (cpu);
    /* item 577 */
    BRANCH_LOGIC (cpu);
    /* item 668 */
    ANDS (cpu);
    /* item 669 */
    SRS (cpu);
    /* item 675 */
    NOADL (cpu);
    /* item 676 */
    IND (cpu);
    /* item 687 */
    MEMOP (cpu);
    /* item 693 */
    STOR (cpu);
    /* item 611 */
    T5_T6 (cpu);
    /* item 716 */
    XY_SB (cpu);
    /* item 717 */
    SB_XY (cpu);
    /* item 718 */
    SREG_CTRL (cpu);
    /* item 657 */
    DAA_DSA (cpu);
    /* item 645 */
    ADL_ABL (cpu);
    /* item 649 */
    SB_ADH (cpu);
    /* item 653 */
    ADH_ABH (cpu);
    /* item 637 */
    SB_AC (cpu);
    /* item 641 */
    AC_SB (cpu);
    /* item 710 */
    DL_ADL (cpu);
    /* item 711 */
    DL_ADH (cpu);
    /* item 712 */
    DL_DB (cpu);
    /* item 734 */
    ALU_SETUP (cpu);
    /* item 741 */
    SUMS (cpu);
    /* item 735 */
    PC_SETUP (cpu);
    /* item 628 */
    IPC (cpu);
    /* item 633 */
    FLAG_IO (cpu);
    /* item 632 */
    FLAG_CTRL (cpu);
    /* item 777 */
    I_FLAG (cpu,0);
    /* item 778 */
    C_FLAG (cpu,0);
    /* item 779 */
    D_FLAG (cpu,0);
    /* item 780 */
    V_FLAG (cpu,0);
    /* item 781 */
    N_FLAG (cpu,0);
    /* item 831 */
    B_FLAG (cpu,0);
    /* item 619 */
    RW_SELECT (cpu);
    /* item 719 */
    WR_DL (cpu);
    /* item 726 */
    RW_PAD (cpu);
    /* item 807 */
    READY_CTRL (cpu,0);
    /* item 603 */
    ENDS (cpu);
    /* item 604 */
    ENDX (cpu);
    /* item 599 */
    EXEC_CTRL (cpu,0);
    /* item 727 */
    T_CTRL (cpu,0);
    return;
    
}

static void T_CTRL(
    Context6502 * cpu,
    int out
) {
}

static void V_FLAG(
    Context6502 * cpu,
    int out
) {
}

static void WR_DL(
    Context6502 * cpu
) {
}

static void XY_SB(
    Context6502 * cpu
) {
}

static void ZERO_ADH0(
    Context6502 * cpu
) {
}

static void ZERO_ADH17(
    Context6502 * cpu
) {
}

static void Z_FLAG(
    Context6502 * cpu,
    int out
) {
}

void Step6502(
    Context6502 *cpu
) {
    // item 77
    TOP_PART (cpu);
    /* item 78 */
    BOTTOM_PART (cpu);
    return;
    
}

int main(
    int argc,
    char **argv
) {
    // item 758
    Context6502 cpu;
    int cycles;
    
    #undef PHI1
    #undef PHI2
    /* item 759 */
    // default conditions (no interrupts, no reset, 6502 ready)
    cpu.nNMI = 1;
    cpu.nIRQ = 1;
    cpu.nRES = 1;
    cpu.RDY = 1;
    
    // DEBUG:
    nRDY = 0;
    PLA[22] = 1;
    /* item 760 */
    // Execute 1000 cycles
    srand ( 0xaabb );
    cycles = 0;
    
    item_762 :
    if (cycles >= 1000) {
        /* item 775 */
        return 0;
    } else {
        /* item 774 */
        //Step6502 (&cpu);
        
        if (cycles >= 2) PLA[22] = 0;
        
        //if (cycles >= 10) PLA[22] = 1;
        //if (cycles >= 12) PLA[22] = 0;
        
        CLOCK (&cpu);
        INT_END (&cpu);
    }
    
    // item 770
    if (cpu.PHI2) {
        /* item 773 */
        // Dummy memory device
        cpu.DATA = rand() & 0xff;
    } else {
    }
    
    // item 764
    cpu.PHI0 ^= 1;
    cycles++;
    goto item_762;
    
}



